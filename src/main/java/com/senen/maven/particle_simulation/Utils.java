package com.senen.maven.particle_simulation;

import static processing.core.PApplet.atan2;
import static processing.core.PApplet.cos;
import static processing.core.PApplet.pow;
import static processing.core.PApplet.sin;
import static processing.core.PApplet.sqrt;
import static processing.core.PConstants.PI;

import java.util.concurrent.ThreadLocalRandom;
import java.util.ArrayList;
import processing.core.PVector;

public class Utils {

	static float distance(Particle p1, Particle p2) {
		return sqrt(pow(p1.pos.x - p2.pos.x, 2) + pow(p1.pos.y - p2.pos.y, 2));
	}

	static boolean collide(Particle p1, Particle p2) {
		return distance(p1, p2) <= p1.r + p2.r;
	}
	
	static float overlap(Particle p1, Particle p2) {
		float overlap = (p1.r + p2.r) - distance(p1, p2);
		if (overlap > 0f) return overlap;
		else return 0f;
	}

	static void solveOverlap(Particle p1, Particle p2) {
	    float overlap = overlap(p1, p2);
	    if (overlap > 0f) {
	        PVector posDiff = PVector.sub(p2.pos, p1.pos);
	        PVector unitVector = posDiff.copy().normalize();
	        PVector displacement = unitVector.copy().mult(overlap);
	        p1.pos.sub(displacement.copy().mult(0.5f));
	        p2.pos.add(displacement.copy().mult(0.5f));
	    }
	}
	
	static void solveEllasticCollision(Particle p1, Particle p2) {
		float contactAngle = atan2(p2.pos.y - p1.pos.y, p2.pos.x - p1.pos.x);
		float theta1 = atan2(p1.vel.x, p1.vel.y); 
		float theta2 = atan2(p2.vel.x, p2.vel.y);
		float v1 = sqrt(pow(p1.vel.x, 2) + pow(p1.vel.y, 2)); 
		float v2 = sqrt(pow(p2.vel.x, 2) + pow(p2.vel.y, 2));
		float halfPi = PI / 2;
		float cAPlusHalfPi = contactAngle + halfPi;
		float second = v1 * sin(theta1 - contactAngle);
		float first = ((v1 * cos(theta1 - contactAngle) * (p1.m - p2.m)) + 
				(2 * p2.m * v2 * cos(theta2 - contactAngle))) / (p1.m + p2.m);
		p1.vel.x = first * cos(contactAngle) + (second * cos(cAPlusHalfPi));
		p1.vel.y = first * sin(contactAngle) + (second * sin(cAPlusHalfPi));
	}


	static void populate(ArrayList<Particle> particles) {
		particles.add(new Particle(200, 200, 300, 0, 100, 50, rColor()));
		particles.add(new Particle(400, 200, -300, 0, 100, 50, rColor()));
		particles.add(new Particle(600, 200, -300, 0, 100, 50, rColor()));
		particles.add(new Particle(800, 200, -300, 0, 100, 50, rColor()));
		particles.add(new Particle(1000, 200, -300, 0, 100, 50, rColor()));
	}
	
	
	static void populate(ArrayList<Particle> particles, int particleN, int mass, int size, int w, int h) {
		for (int i = 0; i < particleN; i++) {
			float vx = random(-100, 100), vy = random(-100, 100);
			float x = random(100, w - 100), y = random(100, h - 100);
			particles.add(new Particle(x, y, vx, vy, mass, size, rColor())); 
		}
	}

	static void populate(ArrayList<Particle> particles, int particleN, int minVel, int maxVel, int mass, int size, int w, int h) {
		for (int i = 0; i < particleN; i++) {
			float x = random(0 + size * 0.5f, w - size * 0.5f);
			float y = random(0 + size * 0.5f, h - size * 0.5f);
			float vx = random(minVel, maxVel);
			float vy = random(minVel, maxVel);
			particles.add(new Particle(x, y, vx, vy, mass, size, rColor())); 
		}
	}

	/**
	 * UNUSED
	 * Method generated by chatGPT, before, I used the 'checkCollision' method, but 
	 * this a more accurate discrete approach and could be used in Continuous 
	 * Collision Detection (CCD) algorithm implementation
	 */
	static float collisionTime(Particle p1, Particle p2, float dt) {
	    // Calculate relative velocity and position
	    float dx = p1.pos.x - p2.pos.x;
	    float dy = p1.pos.y - p2.pos.y;
	    float dvx = p1.vel.x - p2.vel.x;
	    float dvy = p1.vel.y - p2.vel.y;
	    // Calculate quadratic coefficients
	    float a = dvx * dvx + dvy * dvy;
	    float b = 2 * (dx * dvx + dy * dvy);
	    float c = dx * dx + dy * dy - (p2.r + p1.r) * ( p2.r + p1.r);
	    // Calculate discriminant
	    float d = b * b - 4 * a * c;
	    // Check if particles will collide within time step 'dt'
	    if (d < 0) return Float.MAX_VALUE;
	    // Calculate time of collision
	    float t1 = (-b - (float) sqrt(d)) / (2 * a);
	    float t2 = (-b + (float) sqrt(d)) / (2 * a);
	    float t = (t1 > 0 && t1 <= dt) ? t1 : t2;
	    return t;
	}


	// a shame i cant use these methods unless i inherit from PApplet class
	private static float random(float min, float max) {
		return ThreadLocalRandom.current().nextInt((int) min, (int) max);
	}
	
	private static int rColor() {
		int r = ThreadLocalRandom.current().nextInt(255);
		int g = ThreadLocalRandom.current().nextInt(255);
		int b = ThreadLocalRandom.current().nextInt(255);
		return color(r, g, b);
	}
	
	// copied this from processing implementation 
	private static int color(int r, int g, int b) {
		if (r > 255) r = 255; else if (r < 0) r = 0;
		if (g > 255) g = 255; else if (g < 0) g = 0;
		if (b > 255) b = 255; else if (b < 0) b = 0;
		return 0xff000000 | ((int) r << 16) | ((int) g << 8) | (int) b;
	}

}
